{
    "contents" : "#' Lieberson Assessment\n#' \n#' Post-QCA, this function takes in and simulates the parameters of QCA solutions to give a proportion of randomness in solutions.\n#' @param mod name of the model object; the table of solutions for an application of QCA\n#' @param sim the number of simulations the laQCA function should run. The default is set at 2000\n#' @return The proportion of the QCA solutions set that is random\n#' @examples \n#' data(rallies)\n#' P<-rallies$P\n#' R<-rallies$R\n#' C<-rallies$C\n#' U<-rallies$U\n#' \n#' conditions<-data.frame(P,R,C,U)\n#' truth<-truthTable(conditions,outcome=\"P\",sort.by=\"incl\",incl.cut1=0.7,show.cases=TRUE)\n#' truth\n#' mod1 <- eqmcc(truth,details=TRUE,show.cases=TRUE)\n#' mod1\n#' \n#' laQCA(mod1) \n#' @export\nlaQCA<-function(mod, sim=2000, verbose=T, include=c(\"\"), row.dom=F, all.sol=F, omit=c(), dir.exp=c() ){\n  require(QCA)\n  require(bootstrap)\n  ptm <- proc.time()\n  \n  nconf<-rownames(mod$IC$overall$incl.cov) #names of the configuration(s)\n  incl.cut1<-mod$tt$incl.cut1 #consistency score of the configuration \n  incl.cut0<-mod$tt$incl.cut0 #consistency score of the configuration \n  n.cut<-min(mod$tt$tt$n)  #configurational n \n  pop<-dim(mod[[1]]$initial.data)[1] #population size\n  relation<-mod$relation\n  \n  notconditions<-names(mod[[1]][[1]])== c(\"OUT\") |  names(mod[[1]][[1]])== \"n\" | names(mod[[1]][[1]])==   \"incl\" | names(mod[[1]][[1]])== \"PRI\"  | names(mod[[1]][[1]])== \"cases\"\n  conditions<-names(mod$tt$tt)[!notconditions]\n  outcome<-mod$tt$outcome\n  qca.data<-mod$tt$initial.data\n  neg.out<-mod$tt$neg.out\n  \n  rows<-sim*2 #total number of rows\n  out<-qca.data[,outcome] #outcome vector\n  qca.data<-qca.data[,(names(qca.data) %in% conditions)] #matrix of causal conditions\n  data<-data.frame(cname=0,OUT=rep(NA,rows)) #empty data set to simulate into\n  \n  if (sum(outcome > 0 && outcome < 1) == 0){\n    type = \"crisp\"}\n  \n  if (sum(outcome > 0 && outcome < 1) != 0){\n    type = \"fuzzy\"}\n  \n  s.qca.data<-do.call(\"list\", replicate(sim, qca.data, simplify = FALSE))\n  \n  for (j in 1:sim) {\n    \n    if (type==\"crisp\"){\n      \n      for (i in 1:length(qca.data)){ #simulate random causal conditions\n        prob<-c(sum(qca.data[,i]==0)/(dim(qca.data)[1]),sum(qca.data[,i]==1)/dim(qca.data)[1]) #match distributions of data set\n        s.qca.data[[j]][,i]<-sample(c(0,1),pop,prob=prob,replace=T)} \n      #simulate random outcome variable\n      prob<-c(sum(out==0)/(length(out)),sum(out==1)/length(out)) #match distributions of data set\n      s.qca.data[[j]]$OUT<-sample(c(0,1),pop,prob=prob,replace=T)\n    }\n    \n    if (type == \"fuzzy\"){\n      \n      for (i in 1:length(qca.data)){ #simulate random causal conditions\n        ranges<-seq(from=0.1, to=1, by=.1) #better way to do this? could do a for loop\n        prob<-hist(qca.data[,i])[[2]]/dim(qca.data)[1]\n        s.qca.data[[j]][,i]<-sample(ranges,pop,prob=prob,replace=T)\n      } \n      #simulate random outcome variable\n      prob<-hist(out)[[2]]/length(out)\n      s.qca.data[[j]]$OUT<-sample(ranges,pop,prob=prob,replace=T)\n    }\n  }\n  \n  suppressWarnings(confList <- sapply(s.qca.data, function(x){tryCatch( #trap error\n    eqmcc(x,  outcome=c(\"OUT\"),  n.cut=n.cut, incl.cut1=incl.cut1, incl.cut0=incl.cut0, neg.out=neg.out, relation=relation, explain=mod$opts$explain,\n          conditions= c(names(x[,!(names(x) %in% 'OUT')]))),\n    error=function(e) e\n  )}))\n  \n  pars<-rep(NA, sim)\n  pars[sapply(confList, function(x) !inherits(x,\"error\"))]<-1\n  pars[sapply(confList, function(x) inherits(x,\"error\"))]<-0\n  #errs<-sapply(confList, function(x) grepl(\"Nothing to explain\",x) |  grepl(\"All combinations have been included into analysis\",x))\n  #pars[sapply(errs, function(x) sum(x))==1]<-0\n  \n  results<-mean(pars, na.rm=T)\n  \n  bsp<-bootstrap(pars,mean,nboot=1000)[[1]]\n  confInt<-quantile(bsp, prob=c(0.05, .95)) \n  \n  returnme<-list(results, confInt)\n  names(returnme)<-c(\"Probability\",\"Confidence Interval\")\n  return(returnme)\n  \n  #this is where I should assign values to a ltQCA \"class\"\n  \n}\n\n\nrvQCA<-function(mod, sim=2000, verbose=T, include=c(\"\"), row.dom=F, all.sol=F, omit=c(), dir.exp=c() ){\n  require(QCA)\n  require(bootstrap)\n  ptm <- proc.time()\n  \n  nconf<-rownames(mod$IC$overall$incl.cov) #names of the configuration(s)\n  incl.cut1<-mod$tt$incl.cut1 #consistency score of the configuration \n  incl.cut0<-mod$tt$incl.cut0 #consistency score of the configuration \n  n.cut<-min(mod$tt$tt$n)  #configurational n \n  pop<-dim(mod[[1]]$initial.data)[1] #population size\n  relation<-mod$relation\n  \n  notconditions<-names(mod[[1]][[1]])== c(\"OUT\") |  names(mod[[1]][[1]])== \"n\" | names(mod[[1]][[1]])==   \"incl\" | names(mod[[1]][[1]])== \"PRI\"  | names(mod[[1]][[1]])== \"cases\"\n  conditions<-names(mod$tt$tt)[!notconditions]\n  outcome<-mod$tt$outcome\n  qca.data<-mod$tt$initial.data\n  neg.out<-mod$tt$neg.out\n  \n  rows<-sim #total number of rows\n  out<-qca.data[,outcome] #outcome vector\n  qca.data<-qca.data[,(names(qca.data) %in% conditions)] #matrix of causal conditions\n  data<-data.frame(cname=0,OUT=rep(NA,rows)) #empty data set to simulate into\n  \n  splitted<-list()\n  \n  for (solnum in 1:length(mod$solution)){\n    splitted[[solnum]]<-strsplit(mod$solution[[solnum]], \"[*]\")\n    splitted[[solnum]]<-unlist(strsplit(as.character(splitted[[solnum]][[1]]), \"[+]\"))\n  }\n  \n  splitted<-unlist(splitted)\n  splitted<-gsub(\" \",\"\", splitted , fixed=TRUE)\n  splitted<-unique(splitted)\n  \n  if (sum(outcome > 0 && outcome < 1) == 0){\n    type = \"crisp\"}\n  \n  if (sum(outcome > 0 && outcome < 1) != 0){\n    type = \"fuzzy\"}\n  \n  \n  results<-vector()\n  confInt<-list()\n  \n  for (cond in splitted){\n    s.qca.data<-do.call(\"list\", replicate(sim, qca.data, simplify = FALSE))\n    \n    \n    if (type==\"crisp\"){\n      for (j in 1:sim) {\n        \n        #simulate random causal condition\n        prob<-c(sum(qca.data[,(grep(cond, names(qca.data), ignore.case=T))])/(dim(qca.data)[1]), \n                1-sum(qca.data[,(grep(cond, names(qca.data), ignore.case=T))])/(dim(qca.data)[1])) #match distributions of data set\n        s.qca.data[[j]][,(grep(cond, names(qca.data), ignore.case=T))]<-sample(c(0,1),pop,prob=prob,replace=T)\n        s.qca.data[[j]]$OUT<-out\n      }} \n    \n    if (type == \"fuzzy\"){\n      for (j in 1:sim) {\n        \n        for (i in 1:length(qca.data)){ #simulate random causal conditions\n          ranges<-seq(from=0.1, to=1, by=.1) #better way to do this? could do a for loop\n          prob<-hist(qca.data[,i])[[2]]/dim(qca.data)[1]\n          s.qca.data[[j]][,i]<-sample(ranges,pop,prob=prob,replace=T)\n        } \n        #simulate random outcome variable\n        prob<-hist(out)[[2]]/length(out)\n        s.qca.data[[j]]$OUT<-sample(ranges,pop,prob=prob,replace=T)\n      }\n    }\n    \n    confList <- sapply(s.qca.data, function(x){tryCatch( #trap error\n      eqmcc(x,  outcome=c(\"OUT\"),  n.cut=n.cut, incl.cut1=incl.cut1, incl.cut0=incl.cut0, neg.out=neg.out, relation=relation, explain=mod$opts$explain,\n            include=include, row.dom=row.dom, all.sol=all.sol, omit=omit, dir.exp=dir.exp, show.details=F,\n            conditions= c(names(x[,!(names(x) %in% 'OUT')])))[[4]],\n      error=function(e) e\n    )})\n    \n    pars<-rep(NA, sim)\n    pars[sapply(confList,function(x) grepl(cond,as.character(x[[1]]), ignore.case=F))]<-1\n    pars[is.na(pars)]<-0\n    \n    results[cond]<-mean(pars, na.rm=T)\n    \n    bsp<-bootstrap(pars,mean,nboot=1000)[[1]]\n    confInt[[cond]]<-quantile(bsp, prob=c(0.05, .95)) \n    \n    #this is where I should assign values to a ltQCA \"class\"\n    \n  }\n  returnme<-list(results, confInt)\n  names(returnme)<-c(\"Probability\",\"Confidence Interval\")\n  return(returnme)\n  \n  #returned<-mod$IC$incl.cov\n  \n}",
    "created" : 1434484247936.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2361375733",
    "id" : "491F384B",
    "lastKnownWriteTime" : 1435000799,
    "path" : "~/Desktop/package/laQCA/R/laQCA.R",
    "project_path" : "R/laQCA.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}