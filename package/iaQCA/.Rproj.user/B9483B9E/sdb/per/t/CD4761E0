{
    "contents" : "#' Simulation Application\n#' \n#' Internal function to calculate the Irvine Recommendation.\n#' @import QCAGUI bootstrap\n#' @importFrom graphics hist\n#' @importFrom stats glm plogis predict quantile\n#' @importFrom utils flush.console\n#' @param qca.data the data frame of causal conditions.\n#' @param outcome the outcome variable (object name) in the QCA data frame of causal conditions; \\code{\"OUT\"} is the outcome variable for an application of QCA. Default set to \\code{outcome=\"OUT\"}.\n#' @param conditions a set of causal conditions. Default set to \\code{conditions=c(\"\")}\n#' @param sim number of simulations to run. Default set to \\code{sim=10}.\n#' @param ncut configurational n levels for inclusion. Default set to \\code{ncut=2}.\n#' @param type type of QCA application, \\code{\"crisp\"} or \\code{\"fuzzy\"} sets. Default set to \\code{type = \"crisp\"}.\n#' @param inclcut minimum sufficiency score for inclusion. Default set to \\code{inclcut=\"\"}.\n#' @param neg.out [from QCA/QCAGUI package] ``Logical, use negation of outcome (ignored if data is a truth table object).'' Default set to \\code{neg.out=F}.\n#' @param verbose prints the system time used to run the simulation and the percent complete. Default set to \\code{verbose=T}.\n#' @return Simulation information later passed on to conf.table.\n#' @export\nsim.iraQCA<-function(qca.data, outcome=\"OUT\", conditions=c(\"\"), sim=10, ncut=2, type=\"crisp\", inclcut = \"\", neg.out=F, verbose=T){\nptm <- proc.time()\n\nif (all(conditions == c(\"\"))) {\n  conditions <- names(qca.data[,!(names(qca.data) %in% outcome)]) #use all coniditions that are not the outcome, if no conditions are specified\n}\n\nif (inclcut == \"\"){\n  inclcut<-seq(from=.5, to = 1, by=.01) #use precise consistency thresholds\n}\n\npop<-dim(qca.data)[1]  #sample size\nrows<-sim*length(ncut)*length(inclcut)*length(pop)*2 #total number of rows\nout<-qca.data[,outcome] #outcome vector\nqca.data<-qca.data[,!(names(qca.data) %in% outcome)] #matrix of causal conditions\ndata<-data.frame(CTH=0,CNTH=0,CPI=0,NTH=0,OUT=rep(NA,rows)) #empty data set to simulate into\n\nkk<-0 #set counter to 0\n\nfor (j in 1:sim) {\n  \n  for (k in 1:length(inclcut)){\n    \n    for (n in ncut){\n      \n      \n      \n      kk<-kk+1\n      \n      data[kk,1]<-inclcut[k]\n      data[kk,2]<-n\n      data[kk,4]<-pop\n      \n      \n      s.qca.data<-qca.data\n      \n      if (type==\"crisp\"){\n        \n        for (i in 1:length(qca.data)){ #simulate random causal conditions\n          prob<-c(sum(qca.data[,i]==0)/(dim(qca.data)[1]),sum(qca.data[,i]==1)/dim(qca.data)[1]) #match distributions of data set\n          s.qca.data[,i]<-sample(c(0,1),pop,prob=prob,replace=T)} \n        \n        #simulate random outcome variable\n        prob<-c(sum(out==0)/(length(out)),sum(out==1)/length(out)) #match distributions of data set\n        s.qca.data$OUT<-sample(c(0,1),pop,prob=prob,replace=T)\n      }\n      \n      if (type == \"fuzzy\"){\n        \n        for (i in 1:length(qca.data)){ #simulate random causal conditions\n          ranges<-seq(from=0.1, to=1, by=.1) #better way to do this? could do a for loop\n          prob<-hist(qca.data[,i])[[2]]/dim(qca.data)[1]\n          s.qca.data[,i]<-sample(ranges,pop,prob=prob,replace=T)\n        } \n        \n        #simulate random outcome variable\n        prob<-hist(out)[[2]]/length(out)\n        s.qca.data$OUT<-sample(ranges,pop,prob=prob,replace=T)\n      }\n      \n      ##########parsimonious\n      \n      parsimonious <- tryCatch( #trap error\n        eqmcc(s.qca.data,  outcome=c(\"OUT\"),  n.cut=n, incl.cut1=inclcut[k], include = \"?\", neg.out=neg.out,\n              conditions= c(names(s.qca.data[,!(names(s.qca.data) %in% 'OUT')])),details = TRUE, show.cases = TRUE),\n        error=function(e) e\n      )\n      \n      if(!inherits(parsimonious, \"error\")){\n        \n        data[kk,5]<-1 #1 = it returned a configuration with random data!\n        data[kk,3]<-0 # parsimonious solution\n      }\n      \n      #if(grepl(\"None of the values\",parsimonious)[1] | grepl(\"All combinations have been included into analysis\", parsimonious)[1]){\n      if(inherits(parsimonious, \"error\")){\n        #REAL WORK\n        data[kk,5]<-0 #0 = it can't find the pattern that isn't there!\n        data[kk,3]<-0 # parsimonious solution\n      }\n      \n      \n      ########complex\n      \n      kk<-kk+1 # increment row\n      \n      data[kk,1]<-inclcut[k]\n      data[kk,2]<-n\n      data[kk,4]<-pop\n      \n      complex <- tryCatch( #trap error\n        eqmcc(s.qca.data,  outcome=c(\"OUT\"),  n.cut=n, incl.cut1=inclcut[k], neg.out=neg.out,\n              conditions = c(names(s.qca.data[,!(names(s.qca.data) %in% 'OUT')])), details = TRUE, show.cases = TRUE),\n        error=function(e) e\n      )\n      \n      if(!inherits(complex, \"error\")){  \n        data[kk,5]<-1 #1 = it returned a configuration with random data!\n        data[kk,3]<-1 # complex solution\n      }\n      \n      # if(grepl(\"None of the values\",complex)[1] | grepl(\"All combinations have been included into analysis\", complex)[1]){\n      if(inherits(complex, \"error\")){  \n        data[kk,5]<-0 #0 = it can't find the pattern that isn't there!\n        data[kk,3]<-1 # complex solution\n      }\n      \n      \n      captureError<-tryCatch(truthTable(s.qca.data,  outcome=c(\"OUT\"),  n.cut=10, incl.cut1=inclcut[k], include = \"?\", neg.out=neg.out,\n                                        conditions= c(names(s.qca.data[,!(names(s.qca.data) %in% 'OUT')])),details = TRUE, show.cases = TRUE)[[1]][,1], error=function(e) e)\n      \n      # if (grepl(\"replacement has 0 items\",captureError)){data$OUT[kk]<-NA}\n      \n      #if (length(captureError)<=2){data$OUT[kk]<-NA}\n      \n      \n      \n      \n      if (verbose == T){\n        print(paste(round(100*kk/rows, digits=2),\"% done\", sep=\"\"))\n        print(proc.time()-ptm)\n        flush.console()}\n    }}}\nreturn(data)\n}\n\n",
    "created" : 1451596752945.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1508633509",
    "id" : "CD4761E0",
    "lastKnownWriteTime" : 1451598462,
    "path" : "~/Desktop/package/iaQCA/R/sim.iraQCA.R",
    "project_path" : "R/sim.iraQCA.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "type" : "r_source"
}